SyntaxControler for SyntaxCompleter
===================================
The SyntaxControler manages the interaction between the SyntaxView
and the gedit.View classes. The SyntaxControler is is the public
interface of the SyntaxCompleter. It is used by the
SyntaxCompleterPlugin to add the Syntax behaviours to Gedit.


SyntaxControler
---------------

The SyntaxView requires a gedit.View for which it will be handling
requests to complete words.

    >>> from gdp.syntaxcompleter import SyntaxController
    >>> SyntaxController()
    Traceback (most recent call last):
    ...
    TypeError: __init__() takes exactly 2 arguments (1 given)

    >>> from testing import Dummy
    >>> from testing.helpers import get_window, literal
    >>> from syntaxcompleterplugin import SyntaxCompleterPlugin
    >>> import gtk
    >>> import gedit
    >>> dummy = Dummy()
    >>> dummy['app_get_default'] = gedit.App()
    >>> win, view, document = get_window('plugins/gdp/data/snark12.txt')    
    >>> dummy['App_get_active_window'] = win
    >>> dummy['Window_get_group'] = gtk.WindowGroup()
    >>> dummy['Window.get_views'] = [view]
    >>> controller = SyntaxController(view)
    >>> controller
    <gdp.syntaxcompleter.SyntaxController object at ...>


setView()
~~~~~~~~~

The view is bound and unbound to the controller using the setView()
method. It takes an optional reset parameter that rebinds the
current view, for example, when a document's editability changes.

    >>> current_view = controller.view
    >>> current_view
    <View object (GtkSourceView) at ...>

    >>> new_view = gedit.View(document)
    >>> controller.setView(new_view)
    >>> controller.view
    <View object (GtkSourceView) at ...>
    >>> new_view is controller.view
    True
    >>> new_view is current_view
    False

The setView connects and disconnects signals between the controller
and the view and document. When the document is editable, the
key-press-event is connected.

    >>> controller.view.get_editable()
    True
    >>> 'key-press-event' in controller.signal_ids
    True
    >>> controller.view.set_editable(False)
    >>> controller.setView(new_view, is_reset=True)
    >>> new_view is controller.view
    True
    >>> 'key-press-event' in controller.signal_ids
    False

Passing None will disconnect the signals and the view.

    >>> controller.setView(None)
    >>> literal(controller.view)
    None

Passing an existing view connects the signals.

    >>> controller.setView(current_view)
    >>> current_view is controller.view
    True


showSyntaxView()
~~~~~~~~~~~~~~~~

The showSyntaxView() methods displays the SyntaxView widget at the
cursor. It determines the prefix from the left adjacent word and passes
it to the SyntaxView.

    >>> # The widget can only be observed to work when gtk.main()
    >>> # is run.
    >>> syntax_view = controller.showSyntaxView()
    >>> syntax_view
    <SyntaxView object (GtkWindow) at ...>


_calculateSyntaxViewPosition()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The _calculateSyntaxViewPosition() method will return the x and y
coordinate to align the SyntaxView widget with the cursor. When there
is not enough space to display the widget it returns a coordinate to
fit the it to the bottom right of the screen.
        
    >>> end = document.get_iter_at_mark(document.get_insert())
    >>> controller._calculateSyntaxViewPosition(syntax_view, end)
    (15, 301)
    
    >>> win.move(100, 100)
    >>> controller._calculateSyntaxViewPosition(syntax_view, end)
    (15, 301)

    >>> # Window managers treat window postions as suggestions.
    >>> # This test can be unreliable. The top-left and bottom-right
    >>> # corners of the desktop should be visible for this test.
    >>> # Uncomment the coordinate below to run this test.
    >>> right_aligned = controller.view.get_screen().get_width() - 350
    >>> bottom_aligned = controller.view.get_screen().get_height() - 300
    >>> win.move(right_aligned, bottom_aligned)
    >>> pos = controller._calculateSyntaxViewPosition(syntax_view, end)
    >>> #(107, 377)


getWordPrefix()
~~~~~~~~~~~~~~~

This method will return the prefix before the cursor. The prefix is a
3-tuple of the word fragment, its starting iterator and its ending
iterator.

    >>> def print_prefix(prefix):
    ...     return (
    ...         prefix[0], prefix[1].get_offset(), prefix[2].get_offset())     
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_end_iter())
    'This is the Project Gutenberg Etext of The Hunting of the Snark...'

There is no word fragment when the cursor is at the start of the
document.

    >>> document.place_cursor(document.get_start_iter())
    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.get_offset()
    0
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    (None, 0, 0)

When the cursor is at the end of a word, such as 'is', the leading
characters are the prefix.

    >>> cursor_iter.forward_cursor_positions(7)
    True
    >>> document.place_cursor(cursor_iter)
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    ('is', 5, 7)

When the cursor is in the middle of a word, such as 'is', the leading
characters are the prefix.

    >>> cursor_iter.backward_cursor_positions(1)
    True
    >>> document.place_cursor(cursor_iter)
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    ('i', 5, 6)
    
A space is not a word character. There is no prefix. The start and end
positions are identical.

    >>> cursor_iter.backward_cursor_positions(1)
    True
    >>> document.place_cursor(cursor_iter)
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    (None, 5, 5)

Period and other symbols that end a word are not a part of the word.
The first sentence of the test document ends with 'Snark.' at position
64. 'Snark' is the word before position 63. There is no word before
position 64 ('.').

    >>> document.place_cursor(document.get_start_iter())
    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.forward_cursor_positions(63)
    True
    >>> document.place_cursor(cursor_iter)
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    ('Snark', 58, 63)

    >>> cursor_iter.forward_cursor_position()
    True
    >>> document.place_cursor(cursor_iter)
    >>> prefix = controller.getWordPrefix(document)
    >>> print_prefix(prefix)
    (None, 64, 64)


insertWord()
~~~~~~~~~~~~

This method inserts a word into the document. It will raise an error
if the word is None or an empty string.

    >>> controller.insertWord(None, cursor_iter)
    Traceback (most recent call last):
    ...
    AssertionError: The word cannot be None or an empty string.

    >>> controller.insertWord('', cursor_iter)
    Traceback (most recent call last):
    ...
    AssertionError: The word cannot be None or an empty string.

Continuing from the document demonstrated in the getWordPrefix()
section, words can be inserted into the first sentence. Inserting
happens when the start iterator is None or it is the same position
as the cursor.

    >>> sentence_mark = document.create_mark('sentence_end', cursor_iter)
    >>> cursor_iter = document.get_start_iter()
    >>> cursor_iter.forward_cursor_positions(12)
    True
    >>> document.place_cursor(cursor_iter)
    >>> controller.insertWord('Est ', cursor_iter)
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the Est Project Gutenberg Etext of The Hunting of the Snark.'

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.backward_cursor_positions(1)
    True
    >>> document.place_cursor(cursor_iter)
    >>> controller.insertWord('e', None)
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the Este Project Gutenberg Etext of The Hunting of the Snark.'

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> document.place_cursor(cursor_iter)
    >>> controller.insertWord('e')
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the Estee Project Gutenberg Etext of The Hunting of the Snark.'
    
The method can replace text in the document when a start iter is
provided, and it is not the same position at the cursor. The text
between the start and the cursor is deleted, and the word is inserted
at the cursor position.

    >>> start = document.get_iter_at_mark(document.get_insert())
    >>> start.backward_chars(5)
    True
    >>> controller.insertWord('esteem', start)
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the esteem Project Gutenberg Etext of The Hunting of the Snark.'


GSignals
--------

The SyntaxController relies on GSignals to respond the of gedit.View
and the SyntaxView.

Signal test requires some help to isolate the emission and reception
of the sginals.

    >>> from testing.helpers import SignalTester
    >>> signal_tester = SignalTester()
    >>> signal_tester.attachReceptionHarness(controller)
    >>> controller.testeeConnect(
    ...     controller, syntax_view, 'syntax-view', 'syntax-activated',
    ...     controller.on_syntaxview_row_activated)
    >>> controller.testeeConnect(
    ...     controller, controller.view, 'view', 'key-press-event',
    ...     controller.on_view_key_press)
    >>> controller.testeeConnect(
    ...     controller, controller.view, 'view', 'destroy',
    ...     controller.on_view_destroy)

on_syntaxview_row_activated()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SyntaxView sends a syntax-activated signal to return the user's chosen
word. The method calls insertWord. Unlike the afore mentioned method,
when the word is None or an empty string, there is no error

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.backward_chars(6)
    True
    >>> document.place_cursor(cursor_iter)

When the word is None or an empty string, the Document is no changed.

    >>> signal_tester.emitter('syntax-activated', syntax_view, None)
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the esteem Project Gutenberg Etext of The Hunting of the Snark.'    

    >>> signal_tester.emitter('syntax-activated', syntax_view, '')
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the esteem Project Gutenberg Etext of The Hunting of the Snark.'      

When the word is a string (as it should be), the word is inserted into
the document. According the rules of insertWord(), when a space or
symbol preceeds the cursor the word is inserted. Otherwise, the
characters before the cursor are replaced.

    >>> signal_tester.emitter('syntax-activated', syntax_view, 'ed')
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the edesteem Project Gutenberg Etext of The Hunting of the Sn...' 

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.forward_chars(6)
    True
    >>> document.place_cursor(cursor_iter)
    
    >>> signal_tester.emitter('syntax-activated', syntax_view, 'esteemed')
    >>> document.get_text(document.get_start_iter(),
    ...     document.get_iter_at_mark(sentence_mark))
    'This is the esteemed Project Gutenberg Etext of The Hunting of the Sn...'


on_notify_editable()
~~~~~~~~~~~~~~~~~~~~

This method is called for the notify::editable signal from the gedit
View. It is ultimately responsible for enabling and disabling the
SyntaxView widget for syntax completion. The SyntaxView is is enabled
when the key-press-event is listed in the SyntaxController.signal_ids.

    >>> 'key-press-event' in controller.signal_ids
    True
    >>> view.set_editable(False)
    >>> 'key-press-event' in controller.signal_ids
    False
    >>> view.set_editable(True)
    >>> 'key-press-event' in controller.signal_ids
    True


on_view_key_press()
~~~~~~~~~~~~~~~~~~~

SyntaxController uses the on_view_key_press to watch for the
Control-Shift-Space key combination. When the combination is True,
it calls the showSyntaxView() method.

    # Reset the state of the view and syntax_view
    >>> def dummyShowSyntaxView():
    ...     controller.syntax_view = True
    >>> real_showSyntaxView = controller.showSyntaxView
    >>> controller.showSyntaxView = dummyShowSyntaxView
    >>> controller.syntax_view = False
    >>> controller.syntax_view
    False

    >>> from gtk import gdk
    >>> event = gdk.Event(gtk.gdk.KEY_PRESS)
    >>> event.window = controller.view.window
    >>> event.state =  gdk.CONTROL_MASK | gdk.SHIFT_MASK
    >>> event.keyval = gtk.keysyms.space
    >>> signal_tester.emitter('key-press-event', controller.view, event)
    >>> controller.syntax_view
    True

    >>> controller.syntax_view = False

Bad combinations include the state is the wrong bit mask, or the wrong
key was pressed.
    
    >>> event = gdk.Event(gtk.gdk.KEY_PRESS)
    >>> event.window = controller.view.window
    >>> event.state =  gdk.CONTROL_MASK | gdk.SHIFT_MASK | gdk.MOD1_MASK
    >>> event.keyval = gtk.keysyms.space
    >>> signal_tester.emitter('key-press-event', controller.view, event)
    >>> controller.syntax_view
    False
    
    >>> event = gdk.Event(gtk.gdk.KEY_PRESS)
    >>> event.window = controller.view.window
    >>> event.state =  gdk.CONTROL_MASK | gdk.SHIFT_MASK
    >>> event.keyval = gtk.keysyms.Tab
    >>> signal_tester.emitter('key-press-event', controller.view, event)    
    >>> controller.syntax_view
    False

    >>> controller.showSyntaxView = real_showSyntaxView


on_view_destroy() and deactivate()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The deactivate() method removes the detaches the signals and removes
view. The method is called by on_view_destroy() for the destroy signal.

    >>> controller.view
    <View object (GtkSourceView) at ...>
    >>> signal_tester.emitter('destroy', controller.view)   
    >>> literal(controller.view)
    None


Teardown the GSignal test harness
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The signal testing harness can be removed now that sginal testing
is complete. Note that the view was disconnected when the
on_view_destroy() method was tested.

    >>> controller.testeeDisconnect(
    ...     controller, syntax_view, 'syntax-view', 'syntax-activated')
    >>> signal_tester.detachReceptionHarness(controller)

