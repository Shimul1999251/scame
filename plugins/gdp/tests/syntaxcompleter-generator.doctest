SyntaxGenerators
================

The a SyntaxGenerators class represents a word source and syntax rules.
It can build a list of matching words when provided a word prefix.
Some syntax completers require a gedit.Document as their word source.


SyntaxGenerator
---------------

The base SyntaxGenerator class defines the core methods that all
subclasses may choose override. It also provides several helper methods
and properties. The __init__ method requires a gedit.Document.

    >>> from gdp.syntaxcompleter import BaseSyntaxGenerator
    >>> generator = BaseSyntaxGenerator()
    Traceback (most recent call last):
    ...
    TypeError: __init__() takes at least 2 arguments (1 given)

    >>> import gedit
    >>> document = gedit.Document()
    >>> hunting_the_snark = 'plugins/gdp/data/snark12.txt'
    >>> document.load(hunting_the_snark, None, 0, False)
    >>> generator = BaseSyntaxGenerator(document)
    >>> generator
    <gdp.syntaxcompleter.BaseSyntaxGenerator object at ...>

    >>> generator.file_path
    'plugins/gdp/data/snark12.txt'
    >>> generator.text == document.get_text(document.get_start_iter(),
    ...     document.get_end_iter())
    True

    >>> generator.get_words('Ba')
    Traceback (most recent call last):
    ...
    NotImplementedError

The string_before_cursor property and word_char attribute allow the
generator sub-class to get the text before the cursor using its own
rules.

    generator.word_char.pattern
    r'[\w_]'

    generator.string_before_cursor
    ''

TextGenerator
-------------

The TextGenerator class represents plain text sources. The words of the
source are the words it represents, no alteration or interpretation is
applied. Words are identified by common word boundaries like
punctuation and line ends.

    >>> from gdp.syntaxcompleter import TextGenerator
    >>> text_generator = TextGenerator(document)
    >>> text_generator
    <gdp.syntaxcompleter.TextGenerator object at ...>

    >>> text_generator.file_path
    'plugins/gdp/data/snark12.txt'

    >>> text_generator.text
    'This is the Project Gutenberg Etext of The Hunting of the Snark...'

The get_words() method returns a 2-tuple of is_athorative and a set of
all words in the generator.

    >>> is_authoritative, words = text_generator.get_words()
    >>> len(words)
    1987
    >>> type(words)
    <type 'set'>
    >>> sorted(words, key=str.lower)
    ['000', '000x100', '03', '08', '1', '10', '1992', '2', '20', ...]

is_athorative is always False because the TextGenerator works with all
documents instead of a specific GtkSourceView Language.

    >>> is_authoritative
    False

When the generator is created with a prefix, the generator will only
contain words that start with the prefix. Matching is case-insensitive.

    >>> text_generator = TextGenerator(document, prefix='Ba')
    >>> is_authoritative, words = text_generator.get_words()
    >>> len(words)
    16
    >>> sorted(words, key=str.lower)
    ['backwards', 'bade', 'bags', 'bake', 'Baker', 'BAKER', ...]

    >>> text_generator = TextGenerator(document, prefix='Snar')
    >>> is_authoritative, words = text_generator.get_words()
    >>> len(words)
    5
    >>> sorted(words, key=str.lower)
    ['SNARK', 'Snark', 'snark12', 'snarked', 'Snarks']

    >>> text_generator = TextGenerator(document, prefix='snar')
    >>> is_authoritative, lowercase_words = text_generator.get_words()
    >>> lowercase_words == words
    True
    >>> sorted(lowercase_words, key=str.lower)
    ['SNARK', 'Snark', 'snark12', 'snarked', 'Snarks']

    >>> text_generator = TextGenerator(document, prefix='SNAR')
    >>> is_authoritative, uppercase_words = text_generator.get_words()
    >>> lowercase_words == uppercase_words == words
    True
    >>> sorted(lowercase_words, key=str.lower)
    ['SNARK', 'Snark', 'snark12', 'snarked', 'Snarks']

Hyphenated words are included in the list of words.

    >>> text_generator = TextGenerator(document, prefix='What-')
    >>> is_authoritative, words = text_generator.get_words()
    >>> sorted(words)
    ['What-was-his-name', 'What-you-may-call-um']

Underscores are considered word characters. Words that start with, or
contain underscores are included in the list of words.

    >>> hacker_doc = gedit.Document()
    >>> hackerese = 'plugins/gdp/data/hackerese.txt'
    >>> hacker_doc.load(hackerese, None, 0, False)
    >>> print hacker_doc.get_text(hacker_doc.get_start_iter(),
    ...     hacker_doc.get_end_iter())
    H... syntax_generator syntax_completer __call__(self) __dict__ file_ ...

    >>> text_generator = TextGenerator(hacker_doc, prefix='_')
    >>> is_authoritative, words = text_generator.get_words()
    >>> sorted(words)
    ['_', '__call__', '__dict__', '__init__', '_dict', '_private']


PythonGenerator
---------------

The PythonGenerator represents all the identifiers in a Python source
file. The identifiers come from the document, the imports, the builtins,
and the Python keywords.

    >>> from gdp.syntaxcompleter import PythonSyntaxGenerator

    >>> snark_py = 'plugins/gdp/data/snark.py'
    >>> document.load(snark_py, None, 0, False)
    >>> document.place_cursor(document.get_start_iter())
    >>> python_generator = PythonSyntaxGenerator(document)
    >>> python_generator
    <gdp.syntaxcompleter.PythonSyntaxGenerator object at ...>

    >>> python_generator.file_path
    'plugins/gdp/data/snark.py'

    >>> python_generator.text
    '"""An example python module for testing."""...'

The get_words() method returns a 2-tuple of is_authoritative and a set
of all words in the generator.

    >>> is_authoritative, words = python_generator.get_words('A')
    >>> sorted(words)
    ['ArithmeticError', 'AssertionError', 'AttributeError']

The is_authoritative return value may be True or false. It is False when
the set of words from more than one namespace and there is a prefix.

    >>> is_authoritative
    False

Python keywords are among the symbols that can be matched.

    >>> is_authoritative, words = python_generator.get_words('wh')
    >>> sorted(words)
    ['while']

The generator uses the compiled module to get the symbols it contains.
The private _get_parsable_text() method is responsible for returning
compilable code. The line being edited is modified to ensure it is
valid. This can be observed when the main() function is amended with
some sample code.

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> cursor_iter.set_line(document.get_line_count() - 6)
    >>> document.place_cursor(cursor_iter)
    >>> document.insert_at_cursor("""
    ...     found = False
    ...     while not found:
    ...         found = True
    ...     """)

When the line being edited starts a new block, it is replaced with
with code (if True:) to ensure the module will compile.

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> success = cursor_iter.backward_lines(2)
    >>> document.place_cursor(cursor_iter)
    >>> parsable_lines = python_generator._get_parsable_text().splitlines()
    >>> print '\n'.join(parsable_lines[77:80])
        found = False
        if True:
            found = True

When line has the same indentation as the next line, or it is the last
line, it is replaced with 'pass'.

    >>> cursor_iter = document.get_iter_at_mark(document.get_insert())
    >>> success = cursor_iter.forward_lines(1)
    >>> document.place_cursor(cursor_iter)
    >>> parsable_lines = python_generator._get_parsable_text().splitlines()
    >>> print '\n'.join(parsable_lines[77:80])
        found = False
        while not found:
            pass


MarkupGenerator
---------------

The MarkupGenerator creates a vocabulary of elements from the tags used in
the document.

    >>> from gdp.syntaxcompleter import MarkupGenerator

    >>> snark_html = 'plugins/gdp/data/snark.html'
    >>> document.load(snark_html, None, 0, False)
    >>> document.place_cursor(document.get_start_iter())
    >>> markup_generator = MarkupGenerator(document)
    >>> markup_generator
    <gdp.syntaxcompleter.MarkupGenerator object at ...>

    >>> markup_generator.file_path
    'plugins/gdp/data/snark.html'

    >>> print markup_generator.text
    <html> <head> <title>The Hunting of The Snark</title> ...
